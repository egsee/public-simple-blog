<!DOCTYPE html><html lang=" en"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>EGSEE’s BLOG | EGSEE’s BLOG / Copyright©️2022</title><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="EGSEE’s BLOG" /><meta name="author" content="EG" /><meta property="og:locale" content="en_US" /><meta name="description" content="EGSEE’s BLOG / Copyright©️2022" /><meta property="og:description" content="EGSEE’s BLOG / Copyright©️2022" /><link rel="canonical" href="https://egsee.github.io/simple-blog/search" /><meta property="og:url" content="https://egsee.github.io/simple-blog/search" /><meta property="og:site_name" content="EGSEE’s BLOG" /><meta property="og:type" content="website" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="EGSEE’s BLOG" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"EG"},"description":"EGSEE’s BLOG / Copyright©️2022","headline":"EGSEE’s BLOG","url":"https://egsee.github.io/simple-blog/search"}</script><link rel="stylesheet" href="/simple-blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://egsee.github.io/simple-blog/feed.xml" title="EGSEE's BLOG" /><header class="site-header"><div class="wrapper"><a class="site-title" rel="author" href="/simple-blog/">EGSEE&#39;s BLOG</a><nav class="site-nav"> <input type="checkbox" id="nav-trigger" class="nav-trigger" /> <label for="nav-trigger"> <span class="menu-icon"> <svg viewBox="0 0 18 15" width="18px" height="15px"><path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/> </svg> </span> </label><div class="trigger"><a class="page-link" href="/simple-blog/about/">About</a><a class="page-link" href="/simple-blog/archives/index">Archives</a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"> <input type="text" id="search-input" placeholder="search..." step="margin-bottom:10px"><ul id="results-container"><p id="searching-tip" style="margin-top: 30px;text-align: center;">正在努力搜索中...</p></ul><script> window.data = [ { "title": "Go edit replace", "tags" : "", "category": "go", "url": "/go/Go-edit-replace", "content": "如果一个go模块尚未发布，我们无法直接使用模块路径进行导入。这时候可以使用go mod edit。假设exmaple.com/hello依赖于example.com/greeting\n\n// 其中 ../greetings 为文件夹路径，可以与模块名不同\n$ go mod edit -repalce example.com/greeting=../greetings\n// 然后运行\n$ go mod tidy\n\n\n这会在go.mod中生成以下内容:\nreplace example.com/greetings =&gt; ../greetings\n\nrequire example.com/greetings v0.0.0-00010101000000-000000000000" } , { "title": "Docker Entrypoint", "tags" : "", "category": "docker", "url": "/docker/docker-entrypoint", "content": "redis entrypoint example\n\n#!/bin/sh\n...\n# allow the container to be started with `--user`\nif [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then\n\tfind . \\! -user redis -exec chown redis '{}' +\n\texec gosu redis \"$0\" \"$@\"\nfi\n\nexec \"$@\"\n\n\n\n该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：\n\n$ docker run -it redis id\nuid=0(root) gid=0(root) groups=0(root)\n\n\npostgres\n\n#!/bin/bash\nset -e\n\nif [ \"$1\" = 'postgres' ]; then\n chown -R postgres \"$PGDATA\"\n\n if [ -z \"$(ls -A \"$PGDATA\")\" ]; then\n gosu postgres initdb\n fi\n\n exec gosu postgres \"$@\"\nfi\n\nexec \"$@\n\n\n\n 注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。\n\n\n该辅助脚本被拷贝到容器，并在容器启动时通过 ENTRYPOINT 执行：\n\nCOPY ./docker-entrypoint.sh /\n\nENTRYPOINT [\"/docker-entrypoint.sh\"]" } , { "title": "Go数组和切片", "tags" : "", "category": "go", "url": "/go/Go%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87", "content": "数组\n数组的定义\n\nGo 数组是具有相同 唯一类型 的一组已编号且长度固定的数据项序列\n\n声明方式\n\narr := [3]int{1,2,3}\n//or\narr := [...]int{1,2,3,4,5}\n\n\n\n数组声明后值分配为零，在内存中是连续固定不可变的区域。\n数组是值类型，意味着传递数组会重新复制一份传递，这和 C 或 Java 有所不同\n\n\n示例\n\nimport \"fmt\"\n\nfunc main() {\n var arr1 [5]int\n\n for i:=0; i &lt; len(arr1); i++ {\n arr1[i] = i * 2\n }\n\n for i:=0; i &lt; len(arr1); i++ {\n fmt.Printf(\"Array at index %d is %d\\n\", i, arr1[i])\n }\n}\n\n\n切片\n\n定义\n\n切片（slice）是对数组一个连续片段的引用，其底层是数组，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型），可以将其理解为一个可变数组。\n\n声明和定义\n\n// 长度3 容量5的切片\ns1 := make([]int, 3, 5)\n//\ns2 := []int{1,2,3}\ns3 := s1[1:3]\n\n//定义数组\narr := [3]{1,2,3}\ns := a[:] //转换为slice\ns = append(s, 4, 5) // s = {1,2,3,4,5}\nfmt.Println(len(s), cap(s))\n\n\n内存示意\n\n\n例子\n\nimport \"fmt\"\n\nfunc main() {\n var arr1 [6]int\n var slice1 []int = arr1[2:5] // item at index 5 not included!\n\n // load the array with integers: 0,1,2,3,4,5\n for i := 0; i &lt; len(arr1); i++ {\n arr1[i] = i\n }\n\n // print the slice\n for i := 0; i &lt; len(slice1); i++ {\n fmt.Printf(\"Slice at %d is %d\\n\", i, slice1[i])\n }\n\n fmt.Printf(\"The length of arr1 is %d\\n\", len(arr1))\n fmt.Printf(\"The length of slice1 is %d\\n\", len(slice1))\n fmt.Printf(\"The capacity of slice1 is %d\\n\", cap(slice1))\n\n // grow the slice\n slice1 = slice1[0:4]\n for i := 0; i &lt; len(slice1); i++ {\n fmt.Printf(\"Slice at %d is %d\\n\", i, slice1[i])\n }\n fmt.Printf(\"The length of slice1 is %d\\n\", len(slice1))\n fmt.Printf(\"The capacity of slice1 is %d\\n\", cap(slice1))\n\n // grow the slice beyond capacity\n //slice1 = slice1[0:7 ] // panic: runtime error: slice bound out of range\n}\n\n\nslicing 细节\n\ns := make([]int, 5)，s 底层即为上图的数据结构。ptr 是一个指针，指向底层对应的数组。len 是切片的长度 5，cap 是底层数组的容量 5。\n\n当我们执行下面语句时 ：\n\ns2 := s[1:3]\n\n\n做 slicing 的时候，go 会新建一个 slice 值 s2，而底层的数据是不动的。s2 如上图深蓝色，通过更改指针、长度和容量来进行 slicing。这也就是为什么 slicing 的性能非常高的原因。\n\n一个 slice 不能越过 cap 进行操作，这个我们从底层很容易理解，因为就相当于越过底层数组的上界进行非法访问了。\n\n切片扩容\n\n使用内部函数 append 来往切片 slice 后动态追加元素，当 cap 不够时，如果 reslice 后可以放下，那么它会 reslice。例如上面的 s2，底层的数组足以再追加 2 个元素。如果不行，那么它会 new 一个新的底层数组，大小为之前 cap 的两倍，并将之前的元素复制进去:\n\ns := make([]int, 5)\ns = append(s, 6, 7)\nfmt.Println(len(s), cap(s)) // 输出7 10\ns = append(s, 8, 9, 10, 11)\nfmt.Println(len(s), cap(s))//输出11 20\n如果要追加一个slice到另一个slice的话，这样：\n\ns5 := make([]int, 5)\ns6 := []int{11, 22, 33, 44, 55, 66}\ns := append(s5, s6...)\nfmt.Println(s, len(s), cap(s))//输出[0 0 0 0 0 11 22 33 44 55 66] 11 12\n\n\n使用注意\n\n在这样的场景下注意：如果我们只用到一个 slice 的一小部分，那么底层的整个数组也将继续保存在内存当中。当这个底层数组很大，或者这样的场景很多时，可能会造成内存急剧增加，造成崩溃。\n\n所以在这样的场景下，我们可以将需要的分片复制到一个新的 slice 中去，减少内存的占用。例如一个很大的切片 data 里，我们需要的数据是 data[m:n]，那么我们创建一个新的 slice 变量 r，将数据复制到 r 中返回。\n\nmydata := data[m:n]\nr := make([]int, len(mydata))\ncopy(r, mydata)\nreturn r\n\n\n举例区别\n\n切片：\n\nnumbers := []int{1, 2, 3, 4, 5, 6}\n\nfor i, e := range numbers {\n\n if i == len(numbers)-1 {\n\n numbers[0] += e\n\n } else {\n\n numbers[i+1] += e\n\n }\n\n}\nfmt.Println(numbers) // [22 3 6 10 15 21]\n\n\n数组：\n\nnumbers := [...]int{1, 2, 3, 4, 5, 6}\n\nfor i, e := range numbers {\n\n if i == len(numbers)-1 {\n\n numbers[0] += e\n\n } else {\n\n numbers[i+1] += e\n\n }\n\n}\n\nfmt.Println(numbers) // [7 3 5 7 9 11]\n\n\n遍历时数组类型是值类型，而切片是指针类型，每次传递的是指针，所以每次累加，都是改变后的值来累加。\n\n使用 Benchmark 展示 slice 内存使用\n\npackage main\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc generateWithCap(n int) []int {\n\trand.Seed(time.Now().UnixNano())\n\tnums := make([]int, 0, n)\n\tfor i := 0; i &lt; n; i++ {\n\t\tnums = append(nums, rand.Int())\n\t}\n\treturn nums\n}\n\nfunc generate(n int) []int {\n\trand.Seed(time.Now().UnixNano())\n\tnums := make([]int, 0)\n\tfor i := 0; i &lt; n; i++ {\n\t\tnums = append(nums, rand.Int())\n\t}\n\treturn nums\n}\n\nfunc BenchmarkGenerateWithCap(b *testing.B) {\n\tfor n := 0; n &lt; b.N; n++ {\n\t\tgenerateWithCap(1000000)\n\t}\n}\n\nfunc BenchmarkGenerate(b *testing.B) {\n\tfor n := 0; n &lt; b.N; n++ {\n\t\tgenerate(1000000)\n\t}\n}\n\n运行结果：\ngo test -bench='Generate' .\ngoos: darwin\ngoarch: amd64\npkg: example\nBenchmarkGenerateWithCap-8 44 24294582 ns/op\nBenchmarkGenerate-8 34 30342763 ns/op\nPASS\nok example 2.171s\n\n可以看到生成 100w 个数字的随机序列，GenerateWithCap 的耗时比 Generate 少 20%。\n使用 -benchmem 参数看到内存分配的情况：\ngoos: darwin\ngoarch: amd64\npkg: example\nBenchmarkGenerateWithCap-8 43 24335658 ns/op 8003641 B/op 1 allocs/op\nBenchmarkGenerate-8 33 30403687 ns/op 45188395 B/op 40 allocs/op\nPASS\nok example 2.121s\n\nGenerate 分配的内存是 GenerateWithCap 的 6 倍，设置了切片容量，内存只分配一次，而不设置切片容量，内存分配了 40 次。\n\n参考：\nGo语言高性能编程\n数组和切片\n搞懂golang中的数组和切片slice" } , { "title": "Java &lt;T&gt; T 和 T的区别", "tags" : "", "category": "java", "url": "/java/java-T", "content": "导读\n最近在看Java的过程中对形如public &lt;T&gt; T get(...)的写法感到困惑，在网上很难找到合理解释。\n分析\npublic &lt;T&gt; T readObjectData(ByteBuffer buffer, Class&lt;T&gt; type) \n\n\n在上面这个方法中\n&lt;T&gt;代表声明了一个 通用的泛型参数T\nT作为一个实际的占位符，代表返回值为T类型，实际返回类型只会在使用非泛型类型参数调用时才会确定。\n如果这里不定义&lt;T&gt;,那么编译器将认为类型T不存在。\n举例来说：\n如果你传递Class&lt;String&gt;类型则返回的就是String类型、传递Class&lt;Double&gt;则返回Dubbo类型：\nString obj1 = clazz.readObjectData(buffer, String.class);\nMyClass obj2 = clazz.readObjectData(buffer, MyClass.class);\n\n扩展\n大多数初学者有这样的疑惑，估计是还有以下这种类似让人迷惑的写法：\nclass MyClass&lt;T&gt; {\n private T myMethod(T a){\n return a;\n }\n}\n\n这样写因为在类上已经定义了&lt;T&gt;泛型参数，所以无需重复定义，如果你这样写：\nclass MyClass&lt;T&gt; {\n private &lt;T&gt; T myMethod(T a){\n return a;\n }\n}\n\n那么myMethod将返回的泛型类型可能不与MyClass相同，实际上像以下这样定义可能更加清晰：\nclass MyClass&lt;T1&gt; {\n private &lt;T2&gt; T2 myMethod(T2 a){\n return a;\n }\n}\n\n\n参考\nHow to interpret “public &lt;T&gt; T” in Java\nClass Literals as Runtime-Type Tokens\nHow to interpret Java generics like &lt;T&gt; T , &lt;T,V&gt; Query&lt;T&gt; , Class&lt;T&gt;?\nWhat does “&lt;T&gt; T get()” mean?" } , { "title": "Java注解", "tags" : "", "category": "java", "url": "/java/java%E6%B3%A8%E8%A7%A3", "content": "导读\nJava的注解从JDK5引入，有的注解仅仅帮助IDE给出相应提示，有的注解在runtime时会被解析成字节码，通过反射获取注解内容，有的注解专门约束其它注解类，这样的Anotation被称为元注解，本文结合自己的理解将逐一对其进行介绍。\n\n内置注解\nJava的内置注解一共有7个，3个定义在java.lang中，另外4个定义在java.lang.annotation中，为了方便，我这里把java.lang中定义的注解称为内置注解，java.lang.annotation定义的注解成为元注解。\n\n\n\n@Override\n检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。\n@Deprecated\n标记过时方法，如果使用使用，编译器会给出相应警告。\n@SuppressWarnings\n指示编译器去忽略注解中声明的警告。比如：@SuppressWarnings(\"deprecation\"),@SuppressWarnings({\"deprecation\", \"unused\", \"unchecked\"})\n\n元注解（作用于其它注解上的注解）\n@Retention\n标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。\n 它的值有以下几个构成：\n\n RetentionPolicy.SOURCE: Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了。\n RetentionPolicy.CLASS: 编译器将Annotation存储于类对应的.class文件中。默认行为。\n RetentionPolicy.RUNTIME: 编译器将Annotation存储于class文件中，并且可由JVM读入。\n\n\n例子：\n假设有一个我们自定义了一个名叫TestAnn的注解\n\n// @Retention(RetentionPolicy.RUNTIME) #可通过反射获取注解内容\n\n// @Retention(RetentionPolicy.SOURCE) #编译器将忽视TestAnn注释\npublic @interface TestAnn {\n // ...\n}\n\n\n@Target\n对一个自定义注解约束其使用范围，有如下值可选：\n\n ElementType.TYPE - 用在类，接口，枚举，注解的声明\n ElementType.FIELD - 用在字段的和枚举常量\n ElementType.METHOD - 用在方法的声明\n ElementType.PARAMETER - 用在参数的声明\n ElementType.CONSTRUCTOR - 在构造函数的声明\n ElementType.LOCAL_VARIABLE - 用在局部变量的声明\n ElementType.ANNOTATION_TYPE - 用在注释的声明\n ElementType.PACKAGE - 用在包的声明\n 例子：\n // 约束注释只能用在字段和方法上\n@Target(value = { ElementType.FIELD, ElementType.METHOD })\npublic @interface TestAnn {\n// ...\n}\n \n \n\n\n@Documented\n标记这些注解是否包含在用户文档中。\n\n@Inherited\n标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)\n\n@SafeVarargs (Java7支持)\n忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。\n\n@FunctionalInterface（Java8支持）\n标识一个匿名函数或函数式接口。\n\n@Repeatable（Java8支持）\n标识某注解可以在同一个声明上使用多次。\n\n注解的架构\n\nAnnotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等。\n\n\n注解代码的组成\nAnnotation.java\n// Annotation.java\npackage java.lang.annotation;\n\npublic interface Annotation {\n\n boolean equals(Object obj);\n\n int hashCode();\n\n String toString();\n\n Class&lt;? extends Annotation&gt; annotationType();\n}\n\nElementType.java\n// ElementType.java\npackage java.lang.annotation;\n\npublic enum ElementType {\n TYPE, /* 类、接口（包括注释类型）或枚举声明 */\n\n FIELD, /* 字段声明（包括枚举常量） */\n\n METHOD, /* 方法声明 */\n\n PARAMETER, /* 参数声明 */\n\n CONSTRUCTOR, /* 构造方法声明 */\n\n LOCAL_VARIABLE, /* 局部变量声明 */\n\n ANNOTATION_TYPE, /* 注释类型声明 */\n\n PACKAGE /* 包声明 */\n}\n\nRetentionPolicy.java\n//RetentionPolicy.java\npackage java.lang.annotation;\npublic enum RetentionPolicy {\n SOURCE, /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了 */\n\n CLASS, /* 编译器将Annotation存储于类对应的.class文件中。默认行为 */\n\n RUNTIME /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */\n}\n\n\n一个简单的例子\nUlRenderBorder.java\n// UlRenderBorder\npackage com.example.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value = { ElementType.TYPE })\npublic @interface UlBorderRender {\n public String border() default \"border: 1px solid #000\";\n}\n\n\nApp.java\npackage com.example;\n\nimport com.example.annotation.UlBorderRender;\n\npublic class App {\n public static void main(String[] args) {\n Class&lt;?&gt; draw = Draw.class;\n boolean hasUL = draw.isAnnotationPresent(UlBorderRender.class);\n // Method[] methods = draw.getMethods();\n if(hasUL){\n StringBuilder str = new StringBuilder();\n UlBorderRender ulAnn = draw.getAnnotation(UlBorderRender.class);\n str.append(\"&lt;ul&gt;\" + ulAnn.border() + \"&lt;/ul&gt;\");\n System.out.println(str);\n }\n }\n}" } , { "title": "NPM Workspaces", "tags" : "", "category": "frontend", "url": "/frontend/NPM-Workspaces", "content": "Workspaces是什么？\nnpm在2020年10月发布的版本开始支持一个新功能：Workspaces\n\nWorkspaces即工作区，可以帮我们管理包含多个包（package）的项目，这些项目（称为monorepo）可能包含多个package.json，而Workspaces可以方便的对这类项目进行管理。\n\n\n\n举例说明\n一个简单的多包依赖项目的例子如下：\n├── index.js\n├── package.json\n└── packages\n ├── packageA\n │ ├── index.js\n │ └── package.json # Dependencies: `vuepress`,`packageB`\n └── packageB\n ├── index.js\n └── package.json # Dependencies: `vuepress`, `packageA`\n\n\n\n当我们在根目录运行npm install 或 yarn install的时候，npm会在根文件的node_modules下创建彼此的符号链接，以便package能够引入，如下：\n├── node_modules # 根文件 node_modules\n│ ├── vuepress # 依赖的vuepress\n│ ├── packageA # 符号链接包A\n│ └── packageB # 符号链接包B\n\n配置和使用\n\n在根项目目录下的packages.json中配置workspaces关键字：\n\"workspaces\": [\n \"packages/*\",\n ],\n\n子包中的package.json添加dependencies对其它包的依赖\n然后运行npm，则可以在子包中非常方便的使用本地依赖库了。\n\n其它用法\n\n# Run \"test\" script on all packages\nnpm run test --workspaces\nnpm run test -ws\n\n# Runs \"test\" only on packageA\nnpm run test --workspace packageA\nnpm run test -w packageB\n\n# Install `lodash` on `packageA`\nnpm install lodash --workspace packageA\n\n# Install `tap` on `packageB` as a dev dependency\nnpm install tap --workspace packageB --save-dev\n\n# Install `packageA` on `packageB`\nnpm install packageA --workspace packageB\n\n# Install `eslint` in all packages\nnpm install eslint --workspaces\n\n\nnpm 工作区 与 Yarn 工作区\nYarn中也有命令来管理workspaces,\n例如：\nyarn workspace &lt;workspace&gt; add &lt;dependency&gt;\n\n\n使用 Lerna\n使用 npm workspaces 和 yarn workspaces 虽然可以管理一些monorepos\n但对于一些更大的项目来说，它包含更多的依赖树，这时可能就要使用类似Lerna这样的管理工具了。\nLerna 有很多命令来管理大型的monorepo。\n在VuePress项目中结合使用了这两个功能，读者可以参考其用法。\n\n参考\n\n NPM Workspaces\nGetting Started with npm Workspaces\nVuepress repository" } , { "title": "Vscode Could not create temporary directory", "tags" : "", "category": "fregment", "url": "/fregment/Vscode-cound-not-create-dirct", "content": "sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt" } , { "title": "C语言常用类型占用大小", "tags" : "", "category": "c/c++", "url": "/c/c++/c%E6%95%B4%E6%95%B0", "content": "int\n现代操作系统中，int一般占用4个字节(Byte), 共32位。若不考虑正负数，\n当所有的位都为 1 时它的值最大，为 232-1 = 4,294,967,295 ≈ 43亿。\nint建议为一个机器字长，32位机器字长为4字节，64位机器字长为8字节\n16位环境下,int为2字节。\n\nshort\n短整型，占用2个字节\nlong\n长整型，16位和32位为4字节。\nchar\n占用1个字节\n\n64位环境占用字节情况\n操作系统\tshort\tint\tlong\nWin64\t 2\t 4\t 4\n类Unix系统 2\t 4\t 8\n\n\n\n获取某数据类型长度：\n#include &lt;stdio.h&gt;\nint main()\n{\n short a = 10;\n int b = 100;\n \n int short_length = sizeof a;\n int int_length = sizeof(b);\n int long_length = sizeof(long);\n int char_length = sizeof(char);\n \n printf(\"short=%d, int=%d, long=%d, char=%d\\n\", short_length, int_length, long_length, char_length);\n \n return 0;\n}\n// 32 位环境以及 Win64 环境下的运行结果 \nshort=2, int=4, long=4, char=1\n// 64 位 Linux 和 Mac OS 下的运行结果\nshort=2, int=4, long=8, char=1" } , { "title": "MarkText CSS", "tags" : "", "category": "css", "url": "/css/marktext", "content": "MarkText CSS记录的片段…\n\n\n.title-bar[data-v-7cb4eed4] {\n width: 100vw;\n height: 100vh;\n position: relative;\n top: 0;\n color: #fff;\n background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);\n background-size: 400% 400%;\n -webkit-animation: Gradient-data-v-7cb4eed4 15s ease infinite;\n animation: Gradient-data-v-7cb4eed4 15s ease infinite;\n overflow: hidden;\n}\n\n@-webkit-keyframes Gradient-data-v-7cb4eed4 {\n 0% {\n background-position: 0% 50%;\n }\n 50% {\n background-position: 100% 50%;\n }\n 100% {\n background-position: 0% 50%;\n }\n}\n@keyframes Gradient-data-v-7cb4eed4 {\n 0% {\n background-position: 0% 50%;\n }\n 50% {\n background-position: 100% 50%;\n }\n 100% {\n background-position: 0% 50%;\n }\n}" } , { "title": "URL构成", "tags" : "", "category": "common", "url": "/git/common/URL%E6%9E%84%E6%88%90", "content": "导读\n\n URL由多部分构成，不同的语言解析URL函数得到的名称并不完全相同，恰巧在网上看到一篇不错关于URL组成的图形化描述，在此记录。\n\n\nURL组成\n\"https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third\"\n\n\n\n一个这样的URL，可以提取到以下信息：\n+-------------------+---------------------+\n| Part | Data |\n+-------------------+---------------------+\n| Scheme | https |\n| User | bob |\n| Password | bobby |\n| Host | www.lunatech.com |\n| Port | 8080 |\n| Path | /file;p=1 |\n| Path parameter | p=1 |\n| Query | q=2 |\n| Fragment | third |\n+-------------------+---------------------+\n\nhttps://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third\n\\___/ \\_/ \\___/ \\______________/ \\__/\\_______/ \\_/ \\___/\n | | | | | | \\_/ | |\nScheme User Password Host Port Path | | Fragment\n \\_____________________________/ | Query\n | Path parameter\n Authority\n\n使用nodejs URL函数打印的URL信息：\n&gt; const url = \"https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third\"\n\n&gt; new URL(url)\nURL {\n href: 'https://bob:bobby@www.lunatech.com:8080/file;p=1?q=2#third',\n origin: 'https://www.lunatech.com:8080',\n protocol: 'https:',\n username: 'bob',\n password: 'bobby',\n host: 'www.lunatech.com:8080',\n hostname: 'www.lunatech.com',\n port: '8080',\n pathname: '/file;p=1',\n search: '?q=2',\n searchParams: URLSearchParams { 'q' =&gt; '2' },\n hash: '#third'\n}\n\n\n参考\n\n Url encoding the space character or %20" } , { "title": "使用OpenSSL自签名证书", "tags" : "", "category": "internet", "url": "/internet/%E4%BD%BF%E7%94%A8OpenSSL%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6", "content": "导读\n\n 网上关于自签证书的博客资料可以说是很多了，但其中的很多写的都是含糊不清的，此篇文章将会尽量清晰的描述自签名证书和创建CA为自己的服务器颁发证书。\n\n\n什么是数字证书和数字签名\n对于这个问题，阮一峰有一篇 文章 比较形象的解释了这个问题，此处，我们主要记录如何生成。\n\n\n创建CA颁发数字证书\n要给我们的服务器颁发一个数字证书，我们首先需要自己创建一个证书颁发机构 CA ，通常情况下，这个CA是真实的颁发机构，我们使用Chrome访问的https网页时会出现一把锁，这些都是真实的CA颁发的，因此浏览器对此是信任的。\n\n\n为CA生成一个长度为1024的私钥\nopenssl genrsa -out ca.key 1024\n\n\n生成CA机构自己的证书申请文件(.csr)\nopenssl req -new -key ca.key -out ca.csr\n\n\n使用私钥和证书申请文件为CA生成一个自己签名的证书，俗称自签名证书，这里也叫根证书\nopenssl x509 -req -in ca.csr -signkey ca.key -out ca.crt\n\n\n 第二个命令中，req是一个openssl的一个关于证书请求文件的子命令，可以运行openssl req --help查看帮助。最后一个命令的x509是在 ASN.1 中定义的 一种格式，X.509证书里含有公钥、身份信息(比如网络主机名，组织的名称或个体名称等)和签名信息(可以是证书签发机构CA的签名，也可以是自签名)，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名。\n在nginx使用https，nginx配置好后只需将ca.crt颁发给客户端电脑，客户端电脑信任后，浏览器浏览即可看到一把绿锁状态。\n\n\n生成服务器私钥\nopenssl genrsa -out server.key 1024\n\n\n生成服务器证书申请文件\nopenssl req -new -key server.key -out server.csr\n\n使用CA证书签名服务器证书文件\nopenssl x509 -req -in server.csr -out server.crt -CA ca.crt -CAkey ca.key -CAcreateserial\n\n\n自签名证书\n自签名证书顾名思义无需CA参与，自己给自己颁发一个证书，流程相对简单\nopenssl genrsa -out server.key 1024\nopenssl req -new -key server.key -out server.csr\nopenssl x509 -req -in server.csr -signkey server.key -out ca.crt\n\n也可以省略生成密钥过程，让系统自动生成\nopenssl req -x509 -nodes -days 365 -newkey rsa:1024 \\\n-keyout /tmp/server.key -out /tmp/server.crt\n\n\n -nodes 选项禁止加密私钥文件。\n-days 指定过期时间\n\n\n然后输入一些信息：\nCountry Name (2 letter code) [AU]:\nState or Province Name (full name) [Some-State]:\nLocality Name (eg, city) []:\nOrganization Name (eg, company) [Internet Widgits Pty Ltd]:\nOrganizational Unit Name (eg, section) []:\nCommon Name (e.g. server FQDN or YOUR name) []: 这个是你的域名或ip\nEmail Address []:\n\n另外也可以只省略证书请求文件，让系统在签署过程中在内存中自动创建证书请求文件\nopenssl req -new -x509 -key pri.pem -out server.crt -days 365\n\n这样一个证书就申请好了。\n\n其它命令\n查看证书申请文件\n一个服务器申请文件可通过openssl req -in req1.csr -noout -text来输出文件头部分，如下:\nCertificate Request:\n Data:\n Version: 0 (0x0)\n Subject: C=AU, ST=Some-State, O=Internet Widgits Pty Ltd //个人信息\n Subject Public Key Info:\n Public Key Algorithm: rsaEncryption //使用的公钥算法\n Public-Key: (2048 bit)\n Modulus:\n 00:cf:a2:a6:65:ab:e0:38:73:25:8c:d6:33:94:ba:\n d9:4f:6c:93:28:bc:05:81:b9:4c:07:02:93:e2:07:\n c3:0f:57:92:ad:16:e9:57:6f:05:93:44:66:5b:2a:\n 1a:54:5f:80:96:3f:b0:5a:b6:fe:70:fb:a1:4d:f5:\n cf:d3:fb:10:ec:8a:1c:3b:53:6c:dd:49:a8:d7:61:\n 52:b9:9d:06:e3:94:7a:6f:73:4d:f6:7d:7b:ad:55:\n bf:85:28:0d:8c:dc:50:72:5d:bb:9d:f8:ed:2a:18:\n 82:f2:03:b6:00:61:7f:ad:ea:36:57:00:8e:77:df:\n 06:00:97:d3:fe:09:35:a6:3d:0d:47:71:24:03:26:\n 3b:b6:37:f3:24:1d:d9:2f:c7:d8:7e:d2:db:08:b2:\n 49:35:6d:4c:d2:d6:57:0d:e8:6f:4c:ae:5e:50:1c:\n f4:bf:42:df:f1:fb:19:88:eb:0f:05:ad:69:32:da:\n 89:2e:ef:61:e2:95:58:11:27:ba:1c:9f:f4:7f:83:\n 03:de:2f:a6:73:2b:18:b5:46:82:c5:8b:85:19:c0:\n f4:25:d4:d8:ad:b6:81:9f:e1:b2:6d:ab:eb:ef:ba:\n 2d:f3:06:fa:65:54:8c:14:81:65:4b:d2:48:b4:32:\n fd:ae:f7:71:6d:8e:dc:9d:a6:87:47:ee:a7:11:3f:\n ab:a9\n Exponent: 65537 (0x10001)\n Attributes:\n a0:00\n Signature Algorithm: sha256WithRSAEncryption //请求文件使用的数字签名算法\n 95:68:5f:6a:6e:f0:b6:7c:bc:97:c7:c5:ce:76:c0:a8:3f:2a:\n 07:61:5f:75:ee:f0:c3:73:51:c9:b9:d7:59:68:67:06:ca:e5:\n a8:d3:68:19:32:27:ff:18:5f:4b:eb:02:6f:7c:f6:85:db:76:\n 36:56:90:3f:b6:f9:45:4a:1a:4c:74:a9:28:b1:f9:e9:f2:af:\n 2e:4f:d6:38:d5:72:b0:ba:11:36:92:55:9c:a3:48:61:6f:66:\n 73:7b:f6:35:91:cf:8a:23:aa:e1:e1:fd:ed:b1:ea:78:6c:0d:\n 1b:bf:6c:19:4c:a7:1c:dc:09:bb:a5:3f:2f:b2:aa:77:cb:d5:\n 2b:e4:57:bc:14:14:7d:ed:ec:a3:d5:b4:50:93:d3:b0:3a:07:\n 49:0b:fa:e7:42:b8:a6:bf:39:ae:bf:c6:66:37:f3:40:2b:59:\n 75:ce:c4:08:f4:b1:18:2c:48:17:a8:2c:6d:41:1e:5a:a8:86:\n 34:53:a7:ff:fd:e0:95:64:b7:69:9b:86:b7:66:4d:db:74:dc:\n c6:52:18:e9:dc:2a:b0:b1:f9:33:10:a8:d6:0d:1a:ef:0c:ac:\n 1b:fc:c7:61:30:ab:80:01:62:21:06:f1:7b:a7:0c:7c:bf:20:\n e8:d2:b6:24:a3:9a:93:ae:94:02:cf:06:23:74:1f:54:ec:16:\n a7:7e:44:b4\n\n输出subject部分\nopenssl req -in req.csr -subject -noout\n\n使用-pubkey输出请求文件中的公钥\nopenssl req -in req1.csr -pubkey -noout\n\n如果是从申请证书请求时所提供的私钥中提取出公钥，那么以下输出的公钥和上面相同。\n openssl rsa -in server.key -pubout\n\n指定证书请求文件中的签名算法\n如果不指定此项，默认为sha256，也支持其它很多签名算法，可以通过使用openssl dgst --help查看\nopenssl req -new -key server.key -out server.csr -md5\nopenssl req -in server.csr -noout -text | grep Algo\n\n验证请求文件的数字签名（验证文件是否被篡改）\nopenssl req -verify -in server.csr //未被篡改会打印verify OK" } , { "title": "XSS攻击介绍", "tags" : "", "category": "internet", "url": "/internet/XSS%E7%AE%80%E8%BF%B0", "content": "导读\n\n\n XSS 攻击是非常常见的网页攻击了，网上有很多资料，但我始终想写一个简单的总结。\n\n\n何为 XSS?\n\nXSS(Cross site script)指利用浏览器的特性，像指定网页提交特殊字符造成浏览器解析运行的一种攻击手段。XSS 有几种，个人觉得记这些意义不大，因此这里不再赘述，有兴趣的朋友可以在网上搜一下。\n\n如何产生 XSS\n\nXSS 攻击主要来自于用户的输入，如果你的站点存在着 XSS 漏洞，那么用户就可以进行 XSS 攻击，通过运行脚本代码，用户可以获取譬如 Cookie 等较为敏感的信息。\n\n一个 XSS 攻击的例子\n\n这里我引用LearnKu的两张图来说明 XSS 攻击事如何发生的\n在原文中，作者使用了 所见即所得 编辑器，指出虽然所见即所得编辑器过滤了特殊的字符，但依然可能发生 XSS 攻击，原因在于非法用户可能通过其它手段提交数据：\n\n\n 使用 Chrome devtools 提交数据 刷新页面发生 XSS 攻击\n\n\n\n\n\n\n\n 数据库已经有了特殊字符的数据\n\n\n\n\nChrome Devtools 示例攻击提交\n\nfetch(\"http://xss.test/demo\", {\n headers: {\n \"content-type\": \"application/x-www-form-urlencoded\",\n \"upgrade-insecure-requests\": \"1\",\n },\n body: \"_token=AGL1jSjzX152b71UEAQiTzwbYdRGYnECRI17WRiG&amp;title=dangerous%20content+&amp;category_id=2&amp;body=%3Cscript%3Ealert%28%27%E5%AD%98%E5%9C%A8%20XSS%20%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%EF%BC%81%27%29%3C%2Fscript%3E\",\n method: \"POST\",\n mode: \"cors\",\n});\n\n\n监测 XSS 漏洞\n\n可以使用XSS Polylot监测 XSS 漏洞，文章进行了说明并有很多 demo.\n也可以使用一些第三方检测工具Arachni、http-observatory\n\n防范 XSS 攻击\n\n以上的例子说明，虽然各种开源的编辑器已经做了 XSS 过滤，但依然发生 XSS 攻击，这是因为后端和网页展示没有对 XSS 做过滤，因此需要前后端都对特殊字符进行过滤，以确保没有 XSS 漏洞。\nXSS 攻击的本质是浏览器解析了特殊字符的脚本，因此我们只需要在用户输入、页面展示、参数传输这些地方过滤这些特殊字符就可以了：\n\n字符\t转义后的字符\n&amp;\t =&gt; &amp;amp;\n&lt;\t =&gt; &amp;lt;\n&gt;\t =&gt; &amp;gt;\n\"\t =&gt; &amp;quot;\n'\t =&gt; &amp;#x27;\n/\t =&gt; &amp;#x2F;\n\n\n同时 JS 中应注意使用innerHTML,outerHTML，如果使用他们渲染，将有可能出现 XSS 漏洞。 如果使用了 React、Vue 等框架，使用v-html,dangerouslySetInnerHTML也应小心谨慎。\n\n\n 使用 JQuery\n\n\nreturn $(\"&lt;div/&gt;\").text(t).html();\n\n\n\n prototype.js 的 escabeHTML()\n\n\nfunction escapeHTML() {\n return this.replace(/&amp;/g, \"&amp;amp;\")\n .replace(/&lt;/g, \"&amp;lt;\")\n .replace(/&gt;/g, \"&amp;gt;\");\n}\n\n\n\n Underscope 中的 escape\n\n\n// List of HTML entities for escaping.\nvar htmlEscapes = {\n \"&amp;\": \"&amp;amp;\",\n \"&lt;\": \"&amp;lt;\",\n \"&gt;\": \"&amp;gt;\",\n '\"': \"&amp;quot;\",\n \"'\": \"&amp;#x27;\",\n \"/\": \"&amp;#x2F;\",\n};\n\n// Regex containing the keys listed immediately above.\nvar htmlEscaper = /[&amp;&lt;&gt;\"'\\/]/g;\n\n// Escape a string for HTML interpolation.\n_.escape = function (string) {\n return (\"\" + string).replace(htmlEscaper, function (match) {\n return htmlEscapes[match];\n });\n};\n\n// examples\n_.escape(\"Curly, Larry &amp; Moe\");\n// =&gt; \"Curly, Larry &amp;amp; Moe\"\n\n\n其它安全措施\n\n\n 使用 Content Security Policy\nCSP是一个浏览器的特性，能从根本上解决 XSS 漏洞问题\n 设置 Cookie 为 HTTP-only\n这可能防止部分信息泄漏\n\n\n参考\n\n\n Escape HTML with Javascript &gt; URL encoding the space character + or %20" } , { "title": "escape、encodeURI和encodeURIComponent的区别", "tags" : "", "category": "frontend", "url": "/frontend/escape-encodeURI%E5%92%8CencodeURIComponent", "content": "导读\n\n 简要记录了escape,encdoeURI,encodeURIComponent的区别。\n\n\nescape【已弃用】\n对字符串进行unicode编码,编码出来的类似%uxx格式，其中ASCII字母、数字、@*/+ 这些字符不会编码。\n\n 该函数已弃用，不建议使用\n\n\n\nencodeURI\n编码URI的函数，它主要适用于将一个完整的URI进行UTF8编码:\nencodeURI(https://egsee.com/?id=1&amp;name=egsee#+section)。\n\nencodeURIComponent\n适用于编码一个查询querystring，然后将起组装在URI上，如：\nvar world = \"A string with symbols &amp; characters that have special meaning?\";\nvar uri = 'http://example.com/foo?hello=' + encodeURIComponent(world);\n\n\n总结\nChar encUrI encURIComp escape\n* * * *\n. . . .\n_ _ _ _\n- - - -\n~ ~ ~ %7E\n' ' ' %27\n! ! ! %21\n( ( ( %28\n) ) ) %29\n/ / %2F /\n+ + %2B +\n@ @ %40 @\n? ? %3F %3F\n= = %3D %3D\n: : %3A %3A\n# # %23 %23\n; ; %3B %3B\n, , %2C %2C\n$ $ %24 %24\n&amp; &amp; %26 %26\n %20 %20 %20\n% %25 %25 %25\n^ %5E %5E %5E\n[ %5B %5B %5B\n] %5D %5D %5D\n{ %7B %7B %7B\n} %7D %7D %7D\n&lt; %3C %3C %3C\n&gt; %3E %3E %3E\n\" %22 %22 %22\n\\ %5C %5C %5C\n| %7C %7C %7C\n` %60 %60 %60\n\n\n参考\n\n HTML - URL Encoding\nShould I use encodeURI or encodeURIComponent for encoding URLs?\nDifference between escape(), encodeURI(), encodeURIComponent()" } , { "title": "C/C++编译过程", "tags" : "", "category": "c/c++", "url": "/c/c++/c%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B", "content": "预处理/预编译\n对目标代码进行文本处理和翻译，包括：\n\n头部文件(#include)\n条件编译指令(#ifdef、#endif等)、宏(#define)\n删除注释\n添加行号和文件名标识\n\n例：\n#include &lt;iostream&gt; //预编译处理\n// #define DEBUG //预编译处理\nusing namespace std;\n\nint main(){\n string name;\n cout &lt;&lt; \"Enter your name:\";\n cin &gt;&gt; name;\n cout &lt;&lt; \"Hey!\" &lt;&lt; name &lt;&lt; \"Welcome to my blog\\n\";\n #ifdef DEBUG //预编译处理\n cout &lt;&lt; name &lt;&lt; endl;\n #endif\n return 0;\n}\n\n\n\n\n 预处理字符都是以#开头\n\n\n编译\n编译将原文件.cpp编译为汇编语言，这一步主要做语法分析、检查语法是否错误、词法分析产生汇编文件。\n汇编\n讲编译完的文件翻译成机器码，每一条汇编几乎可以直接翻译成一条对应的机器指令，这一步无需语义分析和优化，生成的.o或.obj后缀的二进制对象文件。\n链接\n链接是将生成的一个或者多个中间的文件联合生成可执行文件。链接程序的各个目标文件和库文件(.a)，成为一个能被操作系统执行的可执行文件。\ng++相关命令\nPreprocessing - 由预处理器cpp完成，得到.i后缀的文件\ng++ -E demo.cpp -o demo.i\n\nCompilation - 由编译器ccplus完成，得到.s后缀的汇编文件\ng++ -S demo.i -o demo.s\n\nAssembly - 由汇编器as处理，得到.o的二进制目标文件\ng++ -c demo.s -o demo.o\n\nLinking - 链接器ld来完成，将二进制文件链接后得到可执行文件.out\ng++ demo.o -o demo.out" } , { "title": "HTTP Headers之Referer", "tags" : "", "category": "internet", "url": "/internet/HTTP-Headers%E4%B9%8BReferer", "content": "导读\n\n 本文主要记录一下 Headers 中 Referer 和 Referrer-Policy 等相关字段介绍\n\n\nReferer\n\n\n Referer 字段标记了访问来源，广泛应用于分析、日志、优化缓存等作用。\nReferer 字段是 Referrer 单词的错误拼写，由于历史原因沿用至今。\n当点击一个链接的时候，Referer包含了拥有这个链接的页面地址，而在对其它域名发起资源请求时，则包含了请求页面的地址。\n\n\n\n\n构成\n\nReferer由 origin, path, querystring字段构成，fragment(e.g. “#section”) 或者 username:password 信息将不会包含在其中。\n\n语法\n\n\n Referer: &lt;url&gt;\n\n\n例子\n\n“https://username:password@example.com/foo/bar/”将不会包含在Referer中\n诸如一下的例子会包含在 Referer 中\n\nReferer: https://developer.mozilla.org/en-US/docs/Web/JavaScript\nReferer: https://example.com/page?q=123\nReferer: https://example.com/\n\n\n\n 注意：Referer 可能包含以上域名的全部或部分，这取决于 Referrer Policy\n\n\nReferrer-Policy\n\nReferrer-Policy 字段主要控制将要展示哪些 Referer 信息\n\n有一下几个选项：\n\nReferrer-Policy: no-referrer\nReferrer-Policy: no-referrer-when-downgrade\nReferrer-Policy: origin\nReferrer-Policy: origin-when-cross-origin\nReferrer-Policy: same-origin\nReferrer-Policy: strict-origin\nReferrer-Policy: strict-origin-when-cross-origin\nReferrer-Policy: unsafe-url\n\n\n\n no-referrer\n省略 Referer 字段，发送请求将不会包含任何头字段\n no-referrer-when-downgrade\n这个选项的主要意思是当从 https 访问到 http 中时不展示 referer 信息\n origin\n只展示 Origin\n origin-when-cross-origin\n表示同源且相同级别协议（https =&gt; https, http =&gt; http）下，展示 Referer 所有信息，但在跨域和降级（https =&gt; http）访问时只展示 origin 信息。\n same-origin\n仅在同源下展示 referer 信息\n strict-origin\n仅在安全(https)协议下展示 referer 信息\n strict-origin-when-cross-origin (默认)\n同源请求展示全部 referer 信息, 跨域请求且安全协议下（https =&gt; https）仅展示 origin\n unsafe-url\n任何情况下都展示完整 referer\n\n\n在 HTML 里设置 referer Policy 信息\n\n也可以在 HTML 中设置 referer 策略信息，如\n\n&lt;meta name=\"referrer\" content=\"origin\" /&gt;\n\n\n在 &lt;a&gt;, &lt;area&gt;, &lt;img&gt;, &lt;iframe&gt;, &lt;script&gt;, &lt;link&gt; 标签中可以使用referrerpolicy选项设置 referer policy 信息：\n\n&lt;a href=\"http://example.com\" referrerpolicy=\"origin\"&gt;\n\n\n或者在一个 a, area, 或 link 元素中设置 rel 为 noreferer\n\n\n 注意：上面的 noreferrer 链接关系是不带破折号的。当您使用 &lt;meta&gt; 元素为整个文档指定引用策略时，应使用短划线编写：&lt;meta name=\"referrer\" content=\"no-referrer\"&gt;。\n\n\n与 CSS 集成\n\nCSS 可以从样式表中获取引用的资源。这些资源也遵循推荐人政策：\n\n\n 外部 CSS 样式表使用默认策略 (strict-origin-when-cross-origin)，除非它被 CSS 样式表响应中的 Referrer-Policy HTTP 标头覆盖。\n 对于 &lt;style&gt; 元素或样式属性，使用所有者文档的引用策略。\n\n\n参考\n\n\n Referrer-Policy\nReferer\nContent Security Policy 入门教程" } , { "title": "memset替换字符串的注意点", "tags" : "", "category": "c/c++", "url": "/c/c++/memset-tips", "content": "字符串只读\n\n\n \n memset 原型\nvoid * memset( void * ptr, int value, size_t num )\n\n \n 其中 size_t 即是 unsigned int\n \n \n 参数说明\nptr 为要操作的内存的指针。\nvalue 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，因为 int 和 char 可以根据 ASCII 码相互转换。\nnum 为 ptr 的前 num 个字节。\n \n 注意：参数 value 虽声明为 int，但必须是 unsigned char，所以范围在0 到255 之间。\n \n \n 使用\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\nint main()\n{\n char str[] = \"https://github.com\";\n memset(str, '-', 7);\n puts(str);\n return EXIT_SUCCESS;\n}\n\n\n 输出 ——-github.com\n\n\n\n\n\n 错误使用\n由于字符串是只读的，不能被修改。而memset必须修改目标，所以不能直接将字符指针直接指向字符串，以下使用将在运行时报错\n\n\nint main()\n{\n char *str = \"https://github.com\";\n memset(str, '-', 7);\n puts(str);\n return EXIT_SUCCESS;\n}\n\n报错信息：\nBus error: 10" } , { "title": "C内存分配", "tags" : "", "category": "c/c++", "url": "/c/c++/c%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D", "content": "C 内存分配主要有 malloc、calloc、realoc 三个函数，以下简要介绍\n\n\n内存分区\n\n内存里主要有几个划分，用一张表格表示\n\n\n \n \n 内存分区\n 内容\n 权限\n \n \n \n \n 栈区\n 函数中的普通变量\n 可读可写\n \n \n 堆区\n 动态申请的内存\n 可读可写\n \n \n 静态变量区\n static 修饰的变量\n 可读可写\n \n \n 数据区\n 用于初始化变量的常量\n 只读\n \n \n 代码区\n 代码指令\n 只读\n \n \n\n\nmalloc、calloc、realoc 简介\n\nC\\C++允许我们使用这三个函数直接操作内存，具体就是对堆（Heap）的操作，那么这几种有哪些不同呢？\n\n\n\nmalloc\n\n\n \n 函数原型\n void* malloc (size_t size);\n \n \n 头文件\n 头文件：#include &lt;stdlib.h&gt;\n \n \n 说明\n malloc在 Heap 区域分配一块长度为size字节的连续区域并返回该区域的地址，malloc() 函数不能为所分配的空间初始化值，需要使用 memset()，。在程序结束前，需要使用 free() 进行内存释放。\n \n \n 例子\n \n\n\n int *p = (int *) malloc(sizeof(int));\n memset(p, 100, 1);\n printf(\"%d\\n\", *p); //输出100\n free(p);\n\n\n\n 注意： memset 只能给 int 类型赋值的范围为 0x00 - 0xff (即 0 - 255)，超过将按位赋值。memset 使用介绍»\n\n\ncalloc\n\n\n \n 函数原型\n void* calloc (size_t num, size_t size)\n \n \n 头文件\n #include &lt;stdlib.h&gt;\n \n \n 说明\n calloc和malloc类似，在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。\n \n \n 使用\n \n\n\nchar *ptr = (char *)calloc(10, 10); // 分配100个字节的内存空间\n\n\n\n 注意 由于返回的指针类型未知，所以在使用 calloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型。\n\n\n\n 比较\n以下两种使用等效\n\n\nchar *str1 = (char *)calloc(10, 2);\n// malloc() 分配内存空间并用 memset() 初始化\nchar *str2 = (char *)malloc(20);\nmemset(str2, 0, 20);\n\n\nrealoc\n\n\n \n 函数原型\n void* realloc (void* ptr, size_t size)\n \n \n 头文件\n #include &lt;stdlib.h&gt;\n \n \n 说明\n ptr 为需要重新分配的内存空间指针，size 为新的内存空间的大小，relloc为指定内存指针的动态内存（通常指 malloc 和 calloc 分配的）重新分配大小。\n \n \n 注意\n\n \n 如果 ptr 为 NULL，它的效果和 malloc() 相同，即分配 size 字节的内存空间。\n 如果 size 的值为 0，那么 ptr 指向的内存空间就会被释放，但是由于没有开辟新的内存空间，所以会返回空指针，类似于调用 free()。\n 指针 ptr 必须是在动态内存空间分配成功的指针，形如如下的指针是不可以的：int *i; int a[2]；会导致运行时错误，可以简单的这样记忆：用 malloc()、calloc()、realloc() 分配成功的指针才能被 realloc() 函数接受。\n 成功分配内存后 ptr 将被系统回收，不可再对 ptr 指针做任何操作，包括 free()。相反的，可以对 realloc() 函数的返回值进行正常操作。\n 如果是扩大内存操作会把 ptr 指向的内存中的数据复制到新地址（新地址也可能会和原地址相同，但依旧不能对原指针进行任何操作）；如果是缩小内存操作，原始据会被复制并截取新长度。\n \n \n \n 返回值\n 分配成功返回新的内存地址，可能与 ptr 相同，也可能不同。失败则返回 NULL。\n \n\n\n #define SIZE 5\n int *p = (int *)calloc(SIZE, sizeof(int));\n int *rp;\n for (int i = 0; i &lt; SIZE; ++i)\n {\n p[i] = i;\n }\n // 扩容为之前的两倍\n // 注意这里使用了新指针(rp)而不是(p)，可在realloc分配失败时，防止p指向的内存泄漏\n rp = (int *)realloc(p, SIZE * 2);\n free(p);\n free(rp);\n return 0;\n\n\n总结\n\n malloc 和 colloc 都是动态分配内存，但colloc会在初始化的同时将每个字节的内存值初始化为0。\n realoc 主要功能是对 malloc 和 colloc 分配的内存容量进行调整。" } ]; window.baseUrl = "/simple-blog" </script> <script src="/simple-blog/assets/scripts/search.min.js"></script></div></main><footer class="site-footer h-card"> <data class="u-url" href="/simple-blog/"></data><div class="wrapper"><div class="footer-col-wrapper"><div class="footer-col"><p class="feed-subscribe"> <a href="/simple-blog/feed.xml"> <svg class="svg-icon orange"> <use xlink:href="/simple-blog/assets/minima-social-icons.svg#rss"></use> </svg><span>Subscribe</span> </a></p><ul class="contact-list"><li class="p-name">EG</ul></div><div class="footer-col"><p>EGSEE&#39;s BLOG / Copyright©️2022</p></div></div></div></footer>
